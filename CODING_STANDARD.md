## コーディング規約（関数設計・リファクタリング・コード探索）

この節の規約は、すべてのコーディングエージェントが共通して守ること。

---

### 1. 関数設計の原則

1.1 関数は「単一責務」を原則とする

* 1つの関数に複数の関心事（I/O、ビジネスロジック、フォーマット変換、ログ出力など）を混在させてはならない。
* 関数を新規作成・変更する場合、内部思考レベルでよいので「この関数の責務は1文で何か」を必ず明確化し、それを超える処理を同一関数に詰め込まないこと。

1.2 過密関数の扱い

* 既存コードにおいて、すでに多機能な関数（いわゆる God function）を見つけた場合、さらに別の責務を追加してはならない。
* 「小さな変更だから」という理由で、既に複雑な関数へロジックを足す行為は禁止。必ず「分解」か「委譲」する方向で設計すること。

1.3 関数サイズと複雑度

* 1つの関数が、概ね下記どれかを満たす場合は「分割候補」と判断すること。

  * 論理的な段落が3つ以上ある（事前条件チェック、本体処理、後処理＋ログなど）。
  * ネストが3段階以上。
  * 複数の外部コンポーネント（DB、外部API、ファイルなど）に直接アクセスしている。

---

### 2. リファクタリング時の絶対禁止事項

2.1 空の関数・空実装へのすり替え禁止

* 「リファクタリング」「整理」「関数分割」などの指示を受けた場合でも、既存のロジックを中身のない関数に置き換えたり、振る舞いを削ったりしてはならない。
* 一時的なステップであっても、元の関数のロジックを削除したままコミット相当の提案を出すことは禁止。

2.2 振る舞いの黙示的変更禁止

* ユーザから明示的な許可がない限り、「仕様簡略化」「分岐削除」「異常系の削除」「ログやバリデーションの削除」など、外部から観測可能な挙動を変える変更をしてはならない。
* エラー処理や細かなガード条件を「不要そう」と判断して削ることを禁止する。判断に迷う場合は削らない。

2.3 不完全な分割禁止

* 関数分割の際、元の関数の一部だけを新関数に移し、残りのロジックを「後で書く」前提で削ることは禁止。
* 「リファクタリング後の構造だけ提示し、実装は空にする」ような抽象的な提案は行わない。必ず動作する実装まで落とし込むこと。

---

### 3. リファクタリングの手順（強制プロセス）

リファクタリングを行う場合、以下のステップを内部で必ず踏むこと（ユーザへの出力は要請された範囲でよい）。

3.1 現状挙動の把握

* 対象関数について、現在の挙動を箇条書きで整理すること：

  * 入力の前提条件
  * 正常系で行っている処理の流れ
  * エラーや例外ケースの扱い
  * 副作用（ログ、DB更新、外部API呼び出し、ファイル操作など）
* 呼び出し元、テスト、コメント、型情報から期待挙動を推定し、それに反しないことを自分で確認する。

3.2 分割方針の決定

* 「どのロジックをどの新関数に切り出すか」を決め、簡潔な関数名と責務を内部で定義する。
* 分割後の呼び出し関係（元関数 → 新関数群）が、現状のデータフローと副作用を保つことを確認する。

3.3 実装と再確認

* 新関数群を実装したうえで、元の関数から呼び出すよう書き換える。
* 元の挙動の箇条書きと、新実装を照合し、「どの行がどの責務を担っているか」を対応づける。
* テストコードが存在する場合、それを利用する前提でコードを書く（実行はユーザ環境依存だが、どのテストが影響を受けるかまで言及すること）。

---

### 4. コード探索ポリシー（目的コード片の特定）

4.1 線形読みの禁止

* 大きなファイルやリポジトリ全体に対して、「先頭から順に読む」ことをデフォルトの探索戦略としてはならない。
* 「目的のコード片を探す」タスクでは、まず探索範囲を絞り込むことを優先する。

4.2 探索の初動
コード片を探すタスクを受けた場合、以下の順序で行うこと。

1. 目的のコードの役割を1行で定義する（例：「ユーザ登録フォームのバリデーションロジック」）。

2. その役割から推定されるキーワードを列挙する（関数名/クラス名候補、ドメイン用語、API名など）。

3. これらのキーワードを使い、以下の情報ソースから該当箇所を絞り込む：

   * ファイル名・ディレクトリ構造（例: `user`, `auth`, `signup` 等を含むパス）
   * コード中のシンボル名（関数、メソッド、クラス、インタフェース名）
   * コメントやドキュメント中の見出し・節タイトル

4. 候補が複数ある場合、

   * 入出力型の近さ
   * 使用している依存コンポーネント
   * 呼び出し元からの文脈
     を基準に優先度をつけ、上位候補から詳細を読む。

4.3 ユーザから与えられたポインタの優先利用

* ユーザがファイルパス、クラス名、関数名、行番号、シンボル名などのポインタを提供した場合、それを最優先の手がかりとして扱うこと。
* これらのポインタを無視して、別の場所から読み始めてはならない。
* ポインタが不完全・曖昧な場合でも、まずそれを起点に周辺コードを確認し、そこから再度候補を広げる。

---

### 5. ドキュメントとコードの対応

5.1 ドキュメントにも単一責務を適用

* 関数やモジュールの説明を書く場合、1つの節や段落に複数の責務を詰め込まない。
* 「概要」「入出力」「副作用」「例外」「使用例」など、論理的なまとまりごとに節を分けること。

5.2 ドキュメント更新時の制約

* コードのリファクタリングや関数分割を行った場合、関連ドキュメントの更新を必ず検討する。
* 古い関数名や古い責務の説明を残したままにしない。
* 説明だけ先行して変更し、実装が追随していない状態を作らない。

---

この節に反する変更提案（多機能関数の新規追加、空関数化、仕様削減を伴う「リファクタリング」、無目的な線形読みなど）は行ってはならない。
